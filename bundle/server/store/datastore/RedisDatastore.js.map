{"version":3,"sources":["../../../../server/store/datastore/RedisDatastore.js"],"names":["RedisDataStore","_client","redis","createClient","constant","REDISCLOUD_URL","no_ready_check","on","err","logger","error","JSON","stringify","path","key","Promise","resolve","reject","rediskey","formatRedisKey","get","data","Error","d","parse","Object","prototype","toString","call","e","set","obj","cursor","pattern","batch","redisclient","_scan","client","callback","scan","res","next_cursor","keys","length","allkeys","finished","concat","map","substring","del","_resp","DataStore"],"mappings":"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","file":"RedisDatastore.js","sourcesContent":["import redis from 'redis';\n\nimport DataStore from './DataStore';\nimport constant from 'common/constant';\nimport logger from 'common/logger';\n\nexport default class RedisDataStore extends DataStore {\n\n  constructor() {\n    super();\n    this._client = redis.createClient(constant.REDISCLOUD_URL, {no_ready_check: true});\n    this._client.on('error', function(err) {\n      logger.error(`Redis error: ${JSON.stringify(err)}`);\n    });\n  }\n\n  formatRedisKey(path, key) {\n    return `${path}_${key}`;\n  }\n\n  _read(path, key) {\n    return new Promise((resolve, reject) => {\n      let rediskey = this.formatRedisKey(path, key);\n      this._client.get(\n        rediskey,\n        (err, data) => {\n          if (err) {\n            logger.error(`Redis read error: ${JSON.stringify(err)}`);\n            reject(err);\n          } else if (!data) {\n            logger.error(`Redis found empty data for key ${rediskey}.`);\n            reject(new Error('Redis found empty data.'));\n          } else {\n            try {\n              let d = JSON.parse(data);\n              //console.log(typeof d, Object.prototype.toString.call(d));\n              // TOFIX: validate this in real redis\n              if (Object.prototype.toString.call(d) == '[object String]') {\n                data = d;\n              }\n            } catch (e) {\n              // go on\n            }\n            resolve(data);\n          }\n        });\n    });\n  }\n\n  _write(path, key, data) {\n    return new Promise((resolve, reject) => {\n      this._client.set(\n        this.formatRedisKey(path, key),\n        JSON.stringify(data),\n        (err, obj) => {\n          if (err) {\n            logger.error(`Redis write error: ${JSON.stringify(err)}`);\n            reject(err);\n          } else {\n            resolve(obj);\n          }\n        });\n    });\n  }\n\n  _scan(path) {\n    return new Promise((resolve, reject) => {\n      let cursor = 0;\n      let pattern = `${path}_*`;\n      let batch = '1000';\n      let redisclient = this._client;\n\n      function _scan(client, cursor, pattern, batch, callback) {\n        client.scan(\n          cursor, \n          'MATCH', pattern,\n          'COUNT', batch,\n          (err, res) => {\n            if (err) {\n              logger.error(`Redis scan error: ${JSON.stringify(err)}`);\n              callback(err);\n            } else {\n              let [next_cursor, keys] = res;\n              if (keys.length > 0) {\n                callback(null, keys);\n              }\n              if (next_cursor != 0) {\n                _scan(client, next_cursor, pattern, batch, callback);\n              } else {\n                callback(null, null, true);\n              }\n            }\n          });\n      }\n\n      let allkeys = [];\n      _scan(redisclient, cursor, pattern, batch, (err, keys, finished) => {\n        if (err) {\n          reject(err);\n        } else if (!finished) {\n          allkeys = allkeys.concat(keys.map((key) => {\n            // remove prefix `${path}_`\n            return key.substring(path.length + 1);\n          }));\n        } else if (finished) {\n          resolve(allkeys);\n        }\n      });\n    });\n  }\n\n  _del(path, key) {\n    return new Promise((resolve, reject) => {\n      let rediskey = this.formatRedisKey(path, key);\n      this._client.del(rediskey,\n        (err, _resp) => {\n          if (err) {\n            logger.error(`Redis del error: ${JSON.stringify(err)}`);\n            reject(err);\n          } else {\n            resolve();\n          }\n        });\n    });\n  }\n}\n"]}