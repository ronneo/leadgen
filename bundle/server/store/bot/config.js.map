{"version":3,"sources":["../../../../server/store/bot/config.js"],"names":["KEY","startReaper","dict","_reap","Object","keys","forEach","group_name","group","new_group_dict","key","ttl","new_ttl","constant","ACCESS_TOKEN_REAP_INTERVAL","hash","setInterval","BotConfig","datahandler","datastore","config","initInMemConfig","Promise","resolve","_reject","_read","paths","bot_config","then","data","JSON","parse","catch","err","logger","error","stringify","info","_write","inMemConfig","inMemConfigReaper","email","accessTokens","hasOwnProperty","ACCESS_TOKEN_TTL","crypto","createHash","update","Date","getTime","digest","permissions","getInMemConfigAccessToken","access_token","found","find"],"mappings":"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","file":"config.js","sourcesContent":["import crypto from 'crypto';\n\nimport constant from 'common/constant';\nimport logger from 'common/logger';\n\nconst KEY = 'default';\n\n/* reaper assumes dict to be in the form of\n     {\n       'group_name': {\n         'key': { 'hash': '<value>', ttl: '<ttl>' }\n       },\n       ...\n     }\n\n   reaper will remove the key-hash pair when the ttl is down to zero,\n   reaper will also remove the group_name when all key-hash pairs are \n   removed.\n */\nfunction startReaper(dict) {\n  let _reap = () => {\n    Object.keys(dict).forEach((group_name) => {\n      let group = dict[group_name];\n      let new_group_dict = {};\n      Object.keys(group).forEach((key) => {\n        let {ttl} = group[key];\n        let new_ttl = ttl - constant.ACCESS_TOKEN_REAP_INTERVAL / 1000; // in seconds\n        if (new_ttl > 0) {\n          new_group_dict[key] = {\n            hash: group[key].hash,\n            ttl: new_ttl,\n          };\n        }\n      });\n      if (new_group_dict !== {}) {\n        dict[group_name] = new_group_dict;\n      } else {\n        delete dict[group_name];\n      }\n    });\n  };\n  return setInterval(_reap, constant.ACCESS_TOKEN_REAP_INTERVAL);\n}\n\nexport default class BotConfig {\n  constructor(datahandler) {\n    this.datastore = datahandler.datastore;\n    this.config = {};\n    this.initInMemConfig();\n  }\n\n  load() {\n    return new Promise((resolve, _reject) => {\n      this.datastore._read(this.datastore.paths.bot_config, KEY)\n        .then((data) => {\n          this.config = JSON.parse(data);\n          resolve(this);\n        })\n        .catch((err) => {\n          logger.error(`load bot config failed with: ${JSON.stringify(err)}`);\n          logger.info('create new bot config.');\n          this.config = {};\n          resolve(this);\n        });\n    });\n  }\n\n  save() {\n    return this.datastore._write(\n      this.datastore.paths.bot_config, \n      KEY,\n      JSON.stringify(this.config),\n    )\n    .then(() => {\n      logger.info('bot config saved.');\n      return this;\n    })\n    .catch((err) => {\n      logger.error(`saving bot config failed with: ${JSON.stringify(err)}`);\n      return err;\n    });\n  }\n\n  initInMemConfig() {\n    this.inMemConfig = {};\n    this.inMemConfigReaper = startReaper(this.inMemConfig);\n  }\n\n  getInMemConfigAccessToken(email) {\n    if (!this.inMemConfig.accessTokens) {\n      this.inMemConfig.accessTokens = {};\n    }\n    if (this.inMemConfig.accessTokens.hasOwnProperty(email)) {\n      this.inMemConfig.accessTokens[email].ttl = constant.ACCESS_TOKEN_TTL;\n    } else {\n      let hash = crypto.createHash('sha256')\n        .update(`${email}+${(new Date()).getTime()}`)\n        .digest('hex');\n      this.inMemConfig.accessTokens[email] = {\n        hash: hash,\n        ttl: constant.ACCESS_TOKEN_TTL,\n      };\n    }\n    return this.inMemConfig.accessTokens[email].hash;\n  }\n\n  checkEmailForAuthorized(email) {\n    let permissions = this.config.permissions || {};\n    if (email in permissions) {\n      return this.getInMemConfigAccessToken(email);\n    } else {\n      return null;\n    }\n  }\n\n  checkAccessToken(access_token) {\n    if (this.inMemConfig.accessTokens) {\n      let found = Object.keys(this.inMemConfig.accessTokens).find((key) => {\n        let {hash} = this.inMemConfig.accessTokens[key];\n        return hash == access_token;\n      });\n      return found;\n    }\n    return false;\n  }\n}\n"]}