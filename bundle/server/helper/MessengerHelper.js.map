{"version":3,"sources":["../../../server/helper/MessengerHelper.js"],"names":["sendQuestion","Reaper","datahandler","messageQueue","status","stopFlag","psid","messageObj","push","Promise","resolve","reject","getAccessToken","then","access_token_mgr","page_access_token","get","constant","PAGE_ACCESS_TOKEN_KEY","logger","info","JSON","stringify","method","uri","GRAPH_BASE_URL","qs","access_token","json","err","_res","body","fbtrEvents","LEADGENBOT_MSG_SENT","timeout","_timeout","reaper","fbSendMessageObj","bind","_reap","length","shift","_lastMessageObj","_reject","_check","callback","_reaper","DataHandler","dh","reap","recipientID","nextQid","questionFlow","_sendQuestion","q","question","findQuestionWithQid","questionHandlerMap","type","needNoAnwser","sendMessage","nq","findNextQidOfQuestion","recipient","id","message","text","stopAtQid","nextExpectRespType","questionExpectMap"],"mappings":"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","file":"MessengerHelper.js","sourcesContent":["import { setTimeout } from 'timers';\nimport request from 'request';\n\nimport constant from 'common/constant';\nimport logger from 'common/logger';\nimport { questionHandlerMap, questionExpectMap } from 'server/handler/questionHandlers';\nimport DataHandler from 'server/store/DataHandler';\nimport { fbtrEvents, fbtr } from 'common/fbtr';\n\n/*  liyuhk: messageQueue and reaper\n    To ensure the message is sent as user designed, we need a messageQueue and a reaper.\n    For example, consider following example, user want to send msg in following order\n      1. greeting msg 1\n      2. greeting msg 2\n      3. question msg\n    if we simplely use javascript code to do it, like below\n      request(endpoint, {greeting_msg_1});\n      request(endpoint, {greeting_msg_2});\n      request(endpoint, {question_msg});\n    it may not send in the order we programmed (the reason is request is async). What's correct\n    to do is\n      request(endpoint, {greeting_msg_1}, () => {\n        request(endpoint, {greeting_msg_2}, () => {\n          request(endpoint, {question_msg}, ()=> {\n            ...next msg\n          });\n        }); \n      });\n    but that is a callback hell, so we design a queue for storing all msgs we want to send, and reaper \n    is an infinite recursive function help us to avoid callback hell.\n*/\nclass Reaper {\n  constructor(datahandler) {\n    this.messageQueue = [];\n    this.status = 'idle';\n    this.stopFlag = false;\n    this.datahandler = datahandler;\n  }\n\n  sendMessage(psid, messageObj) {\n    this.messageQueue.push([psid, messageObj]);\n  }\n\n  fbSendMessageObj(psid, messageObj) {\n    return new Promise((resolve, reject) => {\n      this.datahandler.getAccessToken()\n        .then((access_token_mgr) => {\n          let page_access_token = access_token_mgr.get(constant.PAGE_ACCESS_TOKEN_KEY);\n          logger.info(`will send message ${JSON.stringify(messageObj)}.`);\n          request({\n            method: 'POST',\n            uri: `${constant.GRAPH_BASE_URL}/me/messages`,\n            qs: { access_token: page_access_token },\n            json: messageObj,\n          }, \n          (err, _res, body) => {\n            if (err) {\n              logger.info(`Message sending failed with body ${JSON.stringify(body)}}`);\n              reject(err);\n            } else {\n              logger.info(`Message sent with body ${JSON.stringify(body)}`);\n              resolve(messageObj);\n            }\n          });\n          fbtr(fbtrEvents.LEADGENBOT_MSG_SENT, psid);\n        });\n    });\n  }\n  \n  reap(timeout) {\n    let _timeout = timeout || 500;\n    let reaper = this;\n    let fbSendMessageObj = this.fbSendMessageObj.bind(this);\n    function _reap() {\n      if (reaper.stopFlag) {\n        reaper.status = 'idle';\n        reaper.stopFlag = false;\n        return;\n      }\n      if (reaper.messageQueue && reaper.messageQueue.length > 0) {\n        let [psid, messageObj] = reaper.messageQueue.shift();\n        fbSendMessageObj(psid, messageObj)\n          .then((_lastMessageObj) => {\n            _reap();\n          });\n      } else {\n        setTimeout(_reap, _timeout);\n      }\n    }\n    this.status = 'reaping';\n    _reap();\n  }\n\n  stop() {\n    this.stopFlag = true;\n    return new Promise((resolve, _reject) => {\n      let timeout = 100;\n      function _check(callback) {\n        if (this.status !== 'idle') {\n          setTimeout(() => { _check(callback); }, timeout);\n        } else {\n          callback();\n        }\n      }\n      _check(() => { resolve(); });\n    });\n  }\n}\n\nlet _reaper = new Reaper();\nDataHandler.get()\n  .then((dh) => {\n    _reaper.datahandler = dh;\n    _reaper.reap();\n  });\n\nexport function sendQuestion(recipientID, nextQid, questionFlow) {\n  function _sendQuestion(q) {\n    let question = questionFlow.findQuestionWithQid(q);\n    if (question) {\n      let [messageObj, needNoAnwser] = questionHandlerMap[question.type](recipientID, question);\n      _reaper.sendMessage(recipientID, messageObj);\n      if (needNoAnwser) {\n        let nq = questionFlow.findNextQidOfQuestion(question, q);\n        return _sendQuestion(nq);\n      } else {\n        return q;\n      }\n    } else {\n      _reaper.sendMessage(recipientID, {\n        recipient: {id: recipientID},\n        message: { text: 'That is it! Thanks for your time!' },\n      });\n      return q;\n    }\n  }\n\n  return new Promise((resolve, _reject) => {\n    let stopAtQid = _sendQuestion(nextQid);\n    let question = questionFlow.findQuestionWithQid(stopAtQid);\n    let nextExpectRespType = (question && question.type) ? questionExpectMap[question.type] : 'finished';\n    resolve([stopAtQid, nextExpectRespType]);\n  });\n}\n"]}