{"version":3,"sources":["../../../server/noAuthEndpoint/webhook.js"],"names":["init","receivedMessage","event","dh","senderID","sender","id","recipientID","recipient","timeOfMessage","timestamp","message","logger","info","JSON","stringify","Promise","all","getQuestionFlow","getUserProgress","getUserResponse","getUserProfile","getAccessToken","then","questionFlow","userProgress","userResponse","userProfile","accessToken","userID","postback","referral","isProfileFetched","page_access_token","get","constant","PAGE_ACCESS_TOKEN_KEY","fbrequest","uri","GRAPH_BASE_URL","qs","profile","update","catch","err","error","expectRespType","stopAtQid","nextQid","responseHandlerMap","currentQuestion","findQuestionWithQid","endFire","name","trigger","payload","nextExpectRespType","app","WEBHOOK_PATH","req","res","query","send","post","data","body","object","entry","forEach","pageEntry","messaging","messagingEvent","Object","assign","fbtrEvents","LEADGENBOT_MSG_RECEIVED","sendStatus"],"mappings":"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","file":"webhook.js","sourcesContent":["import logger from 'common/logger';\nimport constant from 'common/constant';\nimport fbrequest from 'common/fbrequest';\nimport {sendQuestion} from 'server/helper/MessengerHelper';\nimport {responseHandlerMap} from 'server/handler/responseHandlers';\nimport {fbtrEvents, fbtr} from 'common/fbtr';\nimport { cfbtr } from 'common/cfbtr';\n\nfunction receivedMessage(event, dh) {\n  let senderID = event.sender.id;\n  let recipientID = event.recipient.id;\n  let timeOfMessage = event.timestamp;\n  let message = event.message;\n\n  logger.info(\n    `Received message for user ${senderID} and page ${recipientID} at ${timeOfMessage} ` +\n    `with message: ${JSON.stringify(message)}`\n  );\n\n  Promise.all([\n    dh.getQuestionFlow(),\n    dh.getUserProgress(senderID),\n    dh.getUserResponse(senderID),\n    dh.getUserProfile(senderID),\n    dh.getAccessToken(),\n  ])\n  .then(([questionFlow, userProgress, userResponse, userProfile, accessToken]) => {\n    logger.info(`user ${userProgress.userID} at progress ${JSON.stringify(userProgress.userProgress)}`);\n    if (event.postback && event.postback.referral) {\n      // TODO: handle user info and referral info here\n    }\n\n    if (!userProfile.isProfileFetched()) {\n      // user profile not found in data store, fetching from graph api\n      var page_access_token = accessToken.get(constant.PAGE_ACCESS_TOKEN_KEY);\n      logger.info(`Fetching user profile for ${userProfile.userID}`);\n      fbrequest.get({\n        uri: `${constant.GRAPH_BASE_URL}/${userProfile.userID}`,\n        qs: {\n          'access_token': page_access_token,\n        },\n      })\n      .then((profile) => {\n        logger.info(`user profile fetched ${JSON.stringify(profile)}`);\n        userProfile.update(profile);\n      })\n      .catch((err) => {\n        logger.error(`Profile fetch failed with ${err}`);\n      });\n    }\n\n    let {expectRespType, stopAtQid, nextQid} = userProgress.userProgress;\n    expectRespType = expectRespType || 'genesis';\n    nextQid = nextQid || 0;\n    responseHandlerMap[expectRespType](message, event, questionFlow, userProgress, userResponse)\n      .then((nextQid) => {\n        //before going to next question, check if this question requires event to be fired\n        let currentQuestion = questionFlow.findQuestionWithQid(stopAtQid);\n\n        if (currentQuestion.event?currentQuestion.event.endFire:false) {\n          logger.info(`Trigger reply custom event: ${currentQuestion.event.name}.`);\n          cfbtr(currentQuestion.event.name, currentQuestion, senderID, {\n            trigger:'END',\n            payload:JSON.stringify(message)\n          });\n        }\n\n        // we can hanlde this response, go to next question\n        return sendQuestion(userProfile, nextQid, questionFlow)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n            });\n          });\n      })\n      .catch((err) => {\n        logger.error(`Oops, can not handle user response because ${JSON.stringify(err)}`);\n        logger.info('fall back to re-send last question.');\n        // can not handle this response, repeat last question\n        sendQuestion(userProfile, nextQid, questionFlow)\n          .then(([stopAtQid, nextExpectRespType]) => {\n            userProgress.update({\n              expectRespType: nextExpectRespType,\n              nextQid: nextQid,\n              stopAtQid: stopAtQid,\n            });\n          });\n      });\n  });\n}\n\nexport function init(app, dh) {\n  app.get(constant.WEBHOOK_PATH, (req, res) => {\n    if (req.query['hub.verify_token'] === 'TEMPLATE_BOT') {\n      res.send(req.query['hub.challenge']);\n    } else {\n      res.send('Error, wrong validation token');\n    }\n  });\n\n  app.post(constant.WEBHOOK_PATH, (req, res) => {\n    let data = req.body;\n    if (data.object == 'page') {\n      data.entry.forEach((pageEntry) => {\n        pageEntry.messaging.forEach((messagingEvent) => {\n          if (messagingEvent.message) {\n            receivedMessage(messagingEvent, dh);\n          } else if (messagingEvent.postback) {\n            receivedMessage(Object.assign(messagingEvent, {\n              message: messagingEvent.postback.payload,\n            }), dh);\n          } else {\n            logger.info(`Webhook received unsupported messageEvent: ${JSON.stringify(messagingEvent)}`);\n          }\n          fbtr(fbtrEvents.LEADGENBOT_MSG_RECEIVED, messagingEvent.sender.id);\n        });\n      });\n      res.sendStatus(200);\n    }\n  });\n}\n"]}